# <span style="color:blue"> ***КОМАНДЫ GIT***

* <span style="color:green"> **git confing** 

команда, чтобы задать или изменить имя пользователя. Имя пользователя нужно, чтобы привязывать коммиты к имени. А так же этой командой можно изменять адрес электронной почты, привязааный к коммитам Git.  
> `git confing user.name "Имя"`

> `git confing user.email "Почта"` 
* <span style="color:green">**git init**

команда cсоздать пустой репозиторий Git или вновь инициализировать существующий. При инициализации он создаст скрытую папку. В ней содержатся все объекты и ссылки, которые Git  использует и создает в истории работы над проектом.

> `git init`

* <span style="color:green"> **git add** 

 командой можно добавить отдельный файл в облать подготовленных файлов.

 > `git add актуальное имя файла` 
* <span style="color:green">**git status**

команда для просмотра статуса нужного репозитория, его действие распространяется на подготовленные, неподготовленные и неотслеживаемые файлы.

> `git status`

* <span style="color:green">**git commit -m**  

команда, чтобы зафиксировать или сохранить изменения. Отредактировать сообщение коммита, не меня его снимок можно при помощи  commit --amend, например, можно вернуться и исправить ошибку в сообщении.

>`git commit -m "Коментарий к сохранению"`

> `git commit --amed -m "сообщение"`

* <span style="color:green">**git log** 

команда просмотра изменений, внесенные в репозиторий. Он отображает список последних коммитов в порядке выполнения. Если добавить -p, можно подробно изучить изменения, внесенные в каждый файл. Посмотреть историю коммитов в виде графика для текущей ветки с помощью *--graph* или *--graph --oneline --decorate*. Если нужно посмотреть историю по коммитам по всем веткам то - *--all*. 

> `git log`

> `git log -p`

> `git log --graph`

> `git log --graph --oneline --decorate`

> `git log --all --graph --oneline --decorate`

* <span style="color:green">**git show**

команда просмотра полногго списка изменений, внесенных конкретным коммитом, указав идентификатор или хеш коммита.Можно использовать сокращение хеша.

> `git show хеш коммита`

* <span style="color:green">**git diff**
  
командой можно просмотреть список изменений, внесенных в репозиторий, не подготовленные для фиксации. Для просмотра подготовленных изменений необходимо добавить --staged. Также можно указать имя файла, как параметр и посмотреть изменения, внесенные только в этот файл.

> `git diff`

> `git diff --staged`

> `git diff файл`

* <span style="color:green">**git rm**
  
команда для удаления файла из текущего рабочего дерева. При этом файлы удаляются и из индекса. Можно использовать маски файлов (например *.js) жля удаления всех файлов, соответствующих критерию.

> `git rm dirname/somefile.js`

> `git rm dirname/*.html`

* <span style="color:green">**git mv**
  
команда, чтоб переименовать файл или папку. Для него указывается источник (реально существующий файл или папка) и назначение (существующая папка). При выполнении команды файл и папка, указанные как источник, будут перемещены в папку назначения. Индекс будет обновлен, нужно записать обновления.

> `git mv dir1/somefile.js dir2`

* <span style="color:green">**git checkout**
  
комнда для восстановления файлов рабочего дерева, не подготовленные к коммиту. Для проведения операции требуется указать путь к файлу. Если путь не указан, эта команда изменит указатель HEAD, чтобы задать указанную ветку, как текущую.

> `git checkout somefile.js`

* <span style="color:green">**git reset**

комндой можно восстановит файл рабочего дерева. Потребуется указать путь к файлу, чтобы убрать его из области подготовленных файлов. При этом не будет происходить откат никаких изменений или модификаций - однако файл перейдет в категорию не подготовленных к коммиту. Если нужно выполнить действие для всех подготовленныхфайлов, путь к ним указывать не надо.

> `git reset HEAD somefile.js`

> `git reset HEAD`

* <span style="color:green">**git revert**  

команда отката последнего коммита, создастся новый коммит, содержащий обратные преобразования относительно предыдущего, и добавиться к истории текущей ветки. Откатить проект до заданного коммита можно *revert* и индефикатор коммита.

> `git revert HEAD`

> `git revert 1af17e... (индефикатор коммита)`

***Разница между reset и revert: revert отменяет изменения, записанные только одним коммитом. reset откатывает проект к более раннему состоянию, удаляя все последующие коммиты.***

* <span style="color:green">**git branch**  

команда для создания ветки. Нужно указать имя ветки. Но Git не переключится на неё автоматически, для этого нужно добавить *-b* и параметр checkout. Можно посмотреть полный список веток, используя *branch*. Команда отобразит все ветки, отметит текущую (*) и выделит её ветом. Также можно вывести список удаленных веток с помощью *-а*. Удалить ветку можно с параметром branch *-d* и указание ветки. Если завершили работу над веткой и слили её с другой, можно её удалить без потери истории. Если выполнить эту команду до слияния - появится ошибка,это защитный механизм предотвращает потерю доступа к файлам. Принудительно удалить, то добавит заглавную *-D*.

> `git branch имя файла`

> `git checkout -b имя файла`

> `git branch`

> `git branch -a`

> `git branch -d имя ветки`

> `git branch -D имя ветки`

* <span style="color:green">**git merge**  

команда объединит две ветки, указанную с основной. Если нужно выполнить коммит слияния то *--no-off*.Прервать слияние в случае конфликта с параметром *--abort*. Слияние удаленного репозитория с локальным выполняется параметром *merge*  с указанием имени удаленного репозитория.

> `git merge название ветки`

> `git merge --no-off имя ветки`

> ` git merge --abort`

> `git merge origin`

* <span style="color:green">**git remote**  

команда для добавления удаленного репозитория *-remote add*, указав *shortname* и *url* требуемого репозитория. Просматривать удаленные URL- адреса можно параметром *-v*. Этот параметр отображает удаленне подключения к другим репозиториям. Такая команда открывает доступ к интерфейсу управления удаленными записями, которые хранятся в файле .git/config репозитория. Получить подробные сведения об удаленном репозитории можно с помощью параметра *remote show* с указанием имени репозитория.

> `git remote add awesomeapp https://gi....`

> `git remote -v`

> `git remove show название `

* <span style="color:green">**git push**  

команда отправлять изменения в удаленный репозиторий с указанием имени репозитория и ветки. Эта команда предаёт локадьные изменения в центральный репозиторий, где с ними могут ознакомиться другие участники проекта. Передать новую в удаленный репозиторий параметром push с *-u*, указав имя репозитория и имя ветки. Чтобы избавиться от удаленной ветки, *push* с *--delete*, указав имя удаленного репозитория и имя ветки.

> `git push`

> `git push -u origin new_branch`

> `git push --delete origin existing_br`

* <span style="color:green">**git pull** 

команда для загрузки изменений из удаленного репозитория. Он скачивает копию ткущей ветки с указанного удаленного репозитория и объединяет её с локальной копией. Также можно посмотреть подробные сведения о загруженных файлах с помощью *--verbose*.

> `git pull`

> `git pull --verbose`

* <span style="color:green">**git rebase**  

команда перебазирования - процесс объединения или перемещения последовательности коммитов на новый родительский снимок. Команда изменит основу ветки с одного коммита на другой, как если бы начали ветку с другого коммита.

> `git rebase branch_name`

* <span style="color:green">**git clone**  

команда клонирования. Создает копию существующего репозитория. Так разработчики могут получить рабочую копию центрального репозитория.

[ссылка](https://habr.com/ru/company/ruvds/blog/599929 "Хабр")

[ссылка](https://www.atlassian.com/ru/git/glossary)

<https://proglib.io/p/git-cheatsheet/amp/>


![Хорошего дня!](color.jpg)

🙂

# Хорошего ~~день~~ дня!